<html>
<head>
</head>

<!-- INTRO -->

<body bgcolor="#000000">
<center>
<table width=1300 >
	<tr align=center>
		<td colspan=2>
			<font color="ffffff">	
			<h1><b>CS 766 Computer Vision Assignment 1: High Dynamic Range (HDR)</b></h1>
			<i>Saikat R. Gomes (<a href="mailto=saikat@cs.wisc.edu">saikat@cs.wisc.edu</a>) & Stephen Lazzaro (<a href="mailto=slazzaro@cs.wisc.edu">slazzaro@cs.wisc.edu</a>)</i>
			</font>
		</td>
	</tr>
	<tr>
		<td colspan=2>
			</br>
			<hr>
		</td>
	</tr>
	<tr>
		<td width='315' alight=left valign=top>
			<font color="ffffff">
			<h2>Contents</h2>
			<ol type="0">
			  <li><a href="../index.html">Home</a></li>
			  <li><a href="intro.html">Introduction</li>
			  <li>Implementation</a></li>
			  <ol type="1">
			    <li><a href="imgAcc.html">Image Acquisition</a></li>
			    <li><a href="simple.html">Simple Pixel Averaging</a></li>
			    <li><a href="rc.html">Response Curves</a></li>
			    <li><a href="tonemap.html">Tone Mapping (Matlab)</a></li>
			    <li><a href="rltm.html">Reinhard's Local Tone Mapping</a></li>
			    <li><a href="rgtm.html">Reinhard's Global Tone Mapping</a></li>
			    <li><a href="wards.html">Ward's Algorithm</a></li>
			  </ol>
			  <li><a href="results.html">Results Comparison 1</a></li>
			  <li><a href="results2.html">Results Comparison 2</a></li>
			  <li><a href="dataset.html">Datasets</a></li>
			  <li><a href="code.html">Code</a></li>
			  <li><a href="https://github.com/saikatgomes/CV-P1-HDR/commits/master" target="_blank">Git Logs<a></li>
			  <li><a href="ref.html">References</a></li>
			</ol>
			</font>
		</td>
		<td align=left>
	<!-- #### DISPLAY AREA ### -->
			<font color="ffffff">

<h2><center> Implementation </center></h2>

Our implementation consists of mainly four main parts. </br> </br>

The first part of our implementation (and probably the simplest) is our naive HDR implementation.  This involves taking an average of the pixel values over all images of the various exposures for a particular scene.  We thought it would be an interesting experiment to compare the results for this simple averaging method to the results we retrieved using the standard HDR methods.  Some examples of images that were created with this averaging method are shown in <a href="simple.html">"Simple Pixel Avergaing"</a> section.</br></br>

The second portion of our implementation consists of using Debevec and Maliks' methods to calculate the <a href="rc.html">response functions</a>.</br>
We experimented with various smoothness values (lamda) and found 50-100 to produce the best images. (Again this is subjective to the viewer!)</br>
After the response functions and radiance maps were created the RGB image was converted into HDR format and a *.hdr file for created.
We also experimented with creating false color maps from the radiance maps.</br> </br>
 
The third  portion of our implementation consists of using a variety of tone mapping methods to produce HDR images.</br>
We produced images using 3 types of tonemap methods (2 of which we implemented): </br>
(1) Builtin Matlab tonemap function<<a href="tonemap.html">(See results here)</a>,  </br>
(2) Reinhard et al.'s local tone mapping algorithm<a href="rltm.html">(See results here)</a></br>
(3) Reinhard et al.'s global tone mapping algorithm<a href="rgtm.html">(See results here)</a>  </br></br>

The resulting images varied a lot based on which tone mapping algorithm we used. (see <a href="results.html">comparison 1</a> and <a href="results2.html">comparison 2</a>) </br>

Additionally, the results for the different tone mapping algorithms certainly depended on the scene.  </br>

We experimented with various parameter values (such as saturation, brightness along with smoothness factor) for our different image scenes and found that varing those would greatly enhance the image appearance but at times at the expense of giving a realistic looking image. </br></br>

The fourth main portion of our implementation was building Ward's image alignment algorithm <a href="wards.html">(see here)</a>.</br>
We improved upon Ward's standard image alignment algorithm by putting the images through an edge filter before calculating their x y shifts.  After we retrieved the x y shifts from running the algorithm, we shifted the relevant images and cropped out portions for all of the images based on the minimum and maximum x and y shifts.  We cropped out parts of each image in order to keep the number of pixels constant throughout all of the images for a particular scene, and to attempt to only keep the pixels/image portions which were constant throughout all images of a particular scene.  The algorithm worked much better when given a smaller parameter value for the maximum number of bits to shift, and also a smaller value for the tolerance parameter (i.e. measuring noise near the median pixel value).  It also worked much better when putting the images through an edge filter before running the image alignment algorithm.



		</font>

<!-- #### DISPLAY AREA ### -->			
	</td>
</tr>
<tr align=center>
	<td colspan=2>
		<hr>
		</br>
		</td>

	<tr>

</table>
</center>
<body>
</html>
